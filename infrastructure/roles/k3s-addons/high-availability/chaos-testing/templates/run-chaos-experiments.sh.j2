#!/bin/bash

# Chaos Experiment Runner Script
# Generated by Ansible - DO NOT EDIT MANUALLY

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
NAMESPACE="{{ chaos_namespace | default('litmus') }}"
CONTROL_PLANE_TESTS="{{ enable_control_plane_tests | default(true) }}"
STORAGE_TESTS="{{ enable_storage_tests | default(true) }}"
ETCD_BACKUP_TESTS="{{ enable_etcd_backup_tests | default(true) }}"

# Function to display usage
usage() {
    echo "Usage: $0 [OPTIONS] [EXPERIMENT_TYPE]"
    echo ""
    echo "OPTIONS:"
    echo "  -h, --help              Show this help message"
    echo "  -n, --namespace NAME    Chaos namespace (default: $NAMESPACE)"
    echo "  -w, --wait              Wait for experiment completion"
    echo "  -m, --monitor           Monitor experiment progress in real-time"
    echo "  -c, --cleanup           Cleanup failed experiments before running"
    echo "  -d, --dry-run           Show what would be executed without running"
    echo ""
    echo "EXPERIMENT_TYPE:"
    echo "  all                     Run all enabled experiments (default)"
    echo "  control-plane           Run only control plane experiments"
    echo "  storage                 Run only storage experiments"
    echo "  etcd-backup             Run only etcd backup validation experiments"
    echo "  node-restart-master     Run master node restart experiment"
    echo "  etcd-kill               Run etcd kill experiment"
    echo "  api-server-kill         Run API server kill experiment"
    echo "  longhorn-node-restart   Run Longhorn node restart experiment"
    echo "  disk-fill-storage       Run disk fill experiment"
    echo "  etcd-backup-restore     Run etcd backup restore validation"
    echo ""
    echo "Examples:"
    echo "  $0                      # Run all enabled experiments"
    echo "  $0 control-plane        # Run only control plane experiments"
    echo "  $0 -w etcd-kill         # Run etcd kill experiment and wait for completion"
    echo "  $0 -m all               # Run all experiments with real-time monitoring"
    echo "  $0 -d storage           # Dry run of storage experiments"
}

# Function to log messages
log() {
    local level="$1"
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    case "$level" in
        "INFO")  echo -e "${BLUE}[$timestamp] INFO:${NC} $message" ;;
        "WARN")  echo -e "${YELLOW}[$timestamp] WARN:${NC} $message" ;;
        "ERROR") echo -e "${RED}[$timestamp] ERROR:${NC} $message" ;;
        "SUCCESS") echo -e "${GREEN}[$timestamp] SUCCESS:${NC} $message" ;;
    esac
}

# Function to check if experiment exists
experiment_exists() {
    local experiment_name="$1"
    kubectl get chaosengine "$experiment_name" -n "$NAMESPACE" >/dev/null 2>&1
}

# Function to cleanup failed experiments
cleanup_experiments() {
    log "INFO" "Cleaning up failed or stuck experiments..."
    
    # Get failed experiments
    local failed_experiments
    failed_experiments=$(kubectl get chaosengines -n "$NAMESPACE" -o jsonpath='{.items[?(@.status.engineStatus=="stopped")].metadata.name}' 2>/dev/null || echo "")
    
    if [ -n "$failed_experiments" ]; then
        for exp in $failed_experiments; do
            log "INFO" "Cleaning up failed experiment: $exp"
            kubectl delete chaosengine "$exp" -n "$NAMESPACE" --ignore-not-found=true
        done
    fi
    
    # Clean up old chaosresults
    kubectl delete chaosresults -n "$NAMESPACE" --all --ignore-not-found=true
    
    log "SUCCESS" "Cleanup completed"
}

# Function to wait for experiment completion
wait_for_experiment() {
    local experiment_name="$1"
    local timeout="${2:-1800}"  # 30 minutes default
    
    log "INFO" "Waiting for experiment '$experiment_name' to complete (timeout: ${timeout}s)..."
    
    if kubectl wait --for=condition=Complete chaosengine/"$experiment_name" -n "$NAMESPACE" --timeout="${timeout}s"; then
        log "SUCCESS" "Experiment '$experiment_name' completed successfully"
        
        # Show results
        log "INFO" "Experiment results:"
        kubectl get chaosresult -l chaosUID=$(kubectl get chaosengine "$experiment_name" -n "$NAMESPACE" -o jsonpath='{.metadata.uid}') -n "$NAMESPACE" -o yaml | grep -A 10 "experimentStatus:"
        
        return 0
    else
        log "ERROR" "Experiment '$experiment_name' failed or timed out"
        
        # Show debug information
        log "INFO" "Experiment status:"
        kubectl describe chaosengine "$experiment_name" -n "$NAMESPACE"
        
        return 1
    fi
}

# Function to monitor experiment progress
monitor_experiment() {
    local experiment_name="$1"
    
    log "INFO" "Monitoring experiment '$experiment_name' progress..."
    
    # Monitor in background
    (
        while experiment_exists "$experiment_name"; do
            local status
            status=$(kubectl get chaosengine "$experiment_name" -n "$NAMESPACE" -o jsonpath='{.status.engineStatus}' 2>/dev/null || echo "unknown")
            
            case "$status" in
                "initialized") log "INFO" "Experiment '$experiment_name': Initialized" ;;
                "running")     log "INFO" "Experiment '$experiment_name': Running chaos injection" ;;
                "completed")   log "SUCCESS" "Experiment '$experiment_name': Completed"; break ;;
                "stopped")     log "ERROR" "Experiment '$experiment_name': Stopped/Failed"; break ;;
                *)             log "INFO" "Experiment '$experiment_name': Status unknown ($status)" ;;
            esac
            
            sleep 10
        done
    ) &
    
    local monitor_pid=$!
    
    # Wait for experiment with monitoring
    if wait_for_experiment "$experiment_name"; then
        kill $monitor_pid 2>/dev/null || true
        return 0
    else
        kill $monitor_pid 2>/dev/null || true
        return 1
    fi
}

# Function to run a single experiment
run_experiment() {
    local experiment_name="$1"
    local experiment_file="$2"
    local wait_completion="${3:-false}"
    local monitor_progress="${4:-false}"
    local dry_run="${5:-false}"
    
    log "INFO" "Preparing to run experiment: $experiment_name"
    
    if [ "$dry_run" = "true" ]; then
        log "INFO" "[DRY RUN] Would apply experiment: $experiment_file"
        kubectl apply -f "$experiment_file" --dry-run=client
        return 0
    fi
    
    # Check if experiment already exists and is running
    if experiment_exists "$experiment_name"; then
        local status
        status=$(kubectl get chaosengine "$experiment_name" -n "$NAMESPACE" -o jsonpath='{.status.engineStatus}' 2>/dev/null || echo "unknown")
        
        if [ "$status" = "running" ]; then
            log "WARN" "Experiment '$experiment_name' is already running"
            if [ "$wait_completion" = "true" ] || [ "$monitor_progress" = "true" ]; then
                if [ "$monitor_progress" = "true" ]; then
                    monitor_experiment "$experiment_name"
                else
                    wait_for_experiment "$experiment_name"
                fi
            fi
            return $?
        else
            log "INFO" "Removing existing experiment '$experiment_name' (status: $status)"
            kubectl delete chaosengine "$experiment_name" -n "$NAMESPACE" --ignore-not-found=true
            sleep 5
        fi
    fi
    
    # Apply the experiment
    log "INFO" "Starting experiment: $experiment_name"
    if kubectl apply -f "$experiment_file"; then
        log "SUCCESS" "Experiment '$experiment_name' started successfully"
        
        if [ "$wait_completion" = "true" ] || [ "$monitor_progress" = "true" ]; then
            if [ "$monitor_progress" = "true" ]; then
                monitor_experiment "$experiment_name"
            else
                wait_for_experiment "$experiment_name"
            fi
            return $?
        else
            log "INFO" "Experiment '$experiment_name' is running in background"
            log "INFO" "Monitor with: kubectl get chaosengine $experiment_name -n $NAMESPACE -w"
            return 0
        fi
    else
        log "ERROR" "Failed to start experiment: $experiment_name"
        return 1
    fi
}

# Function to create experiment YAML file
create_experiment_file() {
    local experiment_name="$1"
    local experiment_type="$2"
    local temp_file="/tmp/${experiment_name}.yaml"
    
    case "$experiment_type" in
        "node-restart-master")
            cat > "$temp_file" << 'EOF'
apiVersion: litmuschaos.io/v1alpha1
kind: ChaosEngine
metadata:
  name: node-restart-master
  namespace: {{ chaos_namespace | default('litmus') }}
spec:
  engineState: 'active'
  chaosServiceAccount: litmus-admin
  experiments:
    - name: node-restart
      spec:
        components:
          env:
            - name: TARGET_NODE
              value: ""
            - name: NODE_LABEL
              value: "node-role.kubernetes.io/control-plane"
            - name: TOTAL_CHAOS_DURATION
              value: "120"
            - name: CHAOS_INTERVAL
              value: "30"
            - name: LIB
              value: "litmus"
            - name: RAMP_TIME
              value: "10"
        probe:
          - name: "api-server-probe"
            type: "httpProbe"
            mode: "Continuous"
            runProperties:
              probeTimeout: 10
              retry: 3
              interval: 5
              probePollingInterval: 2
            httpProbe/inputs:
              url: "https://10.0.0.10:6443/healthz"
              insecureSkipTLS: true
              method:
                get:
                  criteria: "=="
                  responseCode: "200"
EOF
            ;;
        "etcd-kill")
            cat > "$temp_file" << 'EOF'
apiVersion: litmuschaos.io/v1alpha1
kind: ChaosEngine
metadata:
  name: etcd-kill-experiment
  namespace: {{ chaos_namespace | default('litmus') }}
spec:
  engineState: 'active'
  chaosServiceAccount: litmus-admin
  experiments:
    - name: pod-delete
      spec:
        components:
          env:
            - name: TARGET_PODS
              value: ""
            - name: PODS_AFFECTED_PERC
              value: "50"
            - name: TARGET_CONTAINER
              value: "etcd"
            - name: NODE_LABEL
              value: "node-role.kubernetes.io/control-plane"
            - name: TOTAL_CHAOS_DURATION
              value: "60"
            - name: CHAOS_INTERVAL
              value: "30"
            - name: FORCE
              value: "false"
            - name: RAMP_TIME
              value: "10"
        probe:
          - name: "etcd-quorum-probe"
            type: "cmdProbe"
            mode: "Continuous"
            runProperties:
              probeTimeout: 10
              retry: 5
              interval: 5
            cmdProbe/inputs:
              command: "kubectl get --raw /metrics | grep etcd_server_has_leader | grep 1"
              source:
                image: "bitnami/kubectl:latest"
EOF
            ;;
        # Add other experiment types as needed
        *)
            log "ERROR" "Unknown experiment type: $experiment_type"
            return 1
            ;;
    esac
    
    echo "$temp_file"
}

# Function to run control plane experiments
run_control_plane_experiments() {
    local wait_completion="$1"
    local monitor_progress="$2"
    local dry_run="$3"
    
    if [ "$CONTROL_PLANE_TESTS" != "true" ]; then
        log "WARN" "Control plane tests are disabled"
        return 0
    fi
    
    log "INFO" "Running control plane chaos experiments..."
    
    local experiments=("node-restart-master" "etcd-kill" "api-server-kill")
    local failed=0
    
    for exp in "${experiments[@]}"; do
        local exp_file
        exp_file=$(create_experiment_file "$exp" "$exp")
        
        if [ $? -eq 0 ]; then
            if ! run_experiment "$exp" "$exp_file" "$wait_completion" "$monitor_progress" "$dry_run"; then
                failed=$((failed + 1))
            fi
            rm -f "$exp_file"
        else
            failed=$((failed + 1))
        fi
        
        # Wait between experiments if not dry run
        if [ "$dry_run" != "true" ] && [ "$exp" != "api-server-kill" ]; then
            log "INFO" "Waiting 30 seconds before next experiment..."
            sleep 30
        fi
    done
    
    if [ $failed -eq 0 ]; then
        log "SUCCESS" "All control plane experiments completed successfully"
        return 0
    else
        log "ERROR" "$failed control plane experiments failed"
        return 1
    fi
}

# Function to run storage experiments
run_storage_experiments() {
    local wait_completion="$1"
    local monitor_progress="$2"
    local dry_run="$3"
    
    if [ "$STORAGE_TESTS" != "true" ]; then
        log "WARN" "Storage tests are disabled"
        return 0
    fi
    
    log "INFO" "Running storage chaos experiments..."
    
    # For now, just log that storage experiments would run
    # Full implementation would create and run Longhorn experiments
    log "INFO" "Storage experiments: longhorn-node-restart, disk-fill-storage"
    
    if [ "$dry_run" = "true" ]; then
        log "INFO" "[DRY RUN] Would run storage experiments"
    else
        log "INFO" "Storage experiments implementation in progress..."
    fi
    
    return 0
}

# Function to run etcd backup experiments
run_etcd_backup_experiments() {
    local wait_completion="$1"
    local monitor_progress="$2"
    local dry_run="$3"
    
    if [ "$ETCD_BACKUP_TESTS" != "true" ]; then
        log "WARN" "etcd backup tests are disabled"
        return 0
    fi
    
    log "INFO" "Running etcd backup validation experiments..."
    
    if [ "$dry_run" = "true" ]; then
        log "INFO" "[DRY RUN] Would run etcd backup validation"
    else
        log "INFO" "etcd backup validation implementation in progress..."
    fi
    
    return 0
}

# Parse command line arguments
WAIT_COMPLETION=false
MONITOR_PROGRESS=false
CLEANUP=false
DRY_RUN=false
EXPERIMENT_TYPE="all"

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            usage
            exit 0
            ;;
        -n|--namespace)
            NAMESPACE="$2"
            shift 2
            ;;
        -w|--wait)
            WAIT_COMPLETION=true
            shift
            ;;
        -m|--monitor)
            MONITOR_PROGRESS=true
            shift
            ;;
        -c|--cleanup)
            CLEANUP=true
            shift
            ;;
        -d|--dry-run)
            DRY_RUN=true
            shift
            ;;
        -*)
            log "ERROR" "Unknown option: $1"
            usage
            exit 1
            ;;
        *)
            EXPERIMENT_TYPE="$1"
            shift
            ;;
    esac
done

# Main execution
main() {
    log "INFO" "Starting chaos experiment runner..."
    log "INFO" "Namespace: $NAMESPACE"
    log "INFO" "Experiment type: $EXPERIMENT_TYPE"
    log "INFO" "Wait for completion: $WAIT_COMPLETION"
    log "INFO" "Monitor progress: $MONITOR_PROGRESS"
    log "INFO" "Dry run: $DRY_RUN"
    
    # Cleanup if requested
    if [ "$CLEANUP" = "true" ]; then
        cleanup_experiments
    fi
    
    # Check if namespace exists
    if ! kubectl get namespace "$NAMESPACE" >/dev/null 2>&1; then
        log "ERROR" "Namespace '$NAMESPACE' does not exist"
        exit 1
    fi
    
    # Check if LitmusChaos is deployed
    if ! kubectl get deployment chaos-operator-ce -n "$NAMESPACE" >/dev/null 2>&1; then
        log "ERROR" "LitmusChaos is not deployed in namespace '$NAMESPACE'"
        exit 1
    fi
    
    # Run experiments based on type
    local exit_code=0
    
    case "$EXPERIMENT_TYPE" in
        "all")
            run_control_plane_experiments "$WAIT_COMPLETION" "$MONITOR_PROGRESS" "$DRY_RUN" || exit_code=1
            run_storage_experiments "$WAIT_COMPLETION" "$MONITOR_PROGRESS" "$DRY_RUN" || exit_code=1
            run_etcd_backup_experiments "$WAIT_COMPLETION" "$MONITOR_PROGRESS" "$DRY_RUN" || exit_code=1
            ;;
        "control-plane")
            run_control_plane_experiments "$WAIT_COMPLETION" "$MONITOR_PROGRESS" "$DRY_RUN" || exit_code=1
            ;;
        "storage")
            run_storage_experiments "$WAIT_COMPLETION" "$MONITOR_PROGRESS" "$DRY_RUN" || exit_code=1
            ;;
        "etcd-backup")
            run_etcd_backup_experiments "$WAIT_COMPLETION" "$MONITOR_PROGRESS" "$DRY_RUN" || exit_code=1
            ;;
        "node-restart-master"|"etcd-kill"|"api-server-kill")
            local exp_file
            exp_file=$(create_experiment_file "$EXPERIMENT_TYPE" "$EXPERIMENT_TYPE")
            if [ $? -eq 0 ]; then
                run_experiment "$EXPERIMENT_TYPE" "$exp_file" "$WAIT_COMPLETION" "$MONITOR_PROGRESS" "$DRY_RUN" || exit_code=1
                rm -f "$exp_file"
            else
                exit_code=1
            fi
            ;;
        *)
            log "ERROR" "Unknown experiment type: $EXPERIMENT_TYPE"
            usage
            exit 1
            ;;
    esac
    
    if [ $exit_code -eq 0 ]; then
        log "SUCCESS" "Chaos experiment runner completed successfully"
    else
        log "ERROR" "Some experiments failed"
    fi
    
    exit $exit_code
}

# Run main function
main 