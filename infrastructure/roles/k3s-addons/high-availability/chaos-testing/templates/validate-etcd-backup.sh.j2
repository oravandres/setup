#!/bin/bash

# etcd Backup Validation Script
# Generated by Ansible - DO NOT EDIT MANUALLY

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
BACKUP_NAMESPACE="etcd-backup"
KUBE_SYSTEM_NAMESPACE="kube-system"
TEST_NAMESPACE="chaos-backup-test"
SNAPSHOT_DIR="/var/lib/rancher/k3s/server/db/snapshots"
BACKUP_FILE_PREFIX="chaos-validation"

# Function to log messages
log() {
    local level="$1"
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    case "$level" in
        "INFO")  echo -e "${BLUE}[$timestamp] INFO:${NC} $message" ;;
        "WARN")  echo -e "${YELLOW}[$timestamp] WARN:${NC} $message" ;;
        "ERROR") echo -e "${RED}[$timestamp] ERROR:${NC} $message" ;;
        "SUCCESS") echo -e "${GREEN}[$timestamp] SUCCESS:${NC} $message" ;;
    esac
}

# Function to display usage
usage() {
    echo "Usage: $0 [OPTIONS] [ACTION]"
    echo ""
    echo "OPTIONS:"
    echo "  -h, --help              Show this help message"
    echo "  -n, --namespace NAME    Test namespace (default: $TEST_NAMESPACE)"
    echo "  -f, --backup-file NAME  Backup file name (default: auto-generated)"
    echo "  -c, --cleanup           Cleanup test resources after validation"
    echo "  -v, --verbose           Verbose output"
    echo ""
    echo "ACTION:"
    echo "  validate                Full backup and restore validation (default)"
    echo "  backup-only             Only test backup creation"
    echo "  restore-only            Only test restore process (requires existing backup)"
    echo "  list-backups            List available backup files"
    echo "  cleanup                 Clean up test resources"
    echo ""
    echo "Examples:"
    echo "  $0                      # Full backup and restore validation"
    echo "  $0 backup-only          # Only create and validate backup"
    echo "  $0 -v validate          # Full validation with verbose output"
    echo "  $0 list-backups         # List available backups"
}

# Function to get etcd pod name
get_etcd_pod() {
    kubectl get pods -n "$KUBE_SYSTEM_NAMESPACE" -l component=etcd -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || {
        log "ERROR" "No etcd pods found in namespace $KUBE_SYSTEM_NAMESPACE"
        return 1
    }
}

# Function to check etcd health
check_etcd_health() {
    local etcd_pod
    etcd_pod=$(get_etcd_pod)
    
    log "INFO" "Checking etcd cluster health..."
    
    if kubectl exec -n "$KUBE_SYSTEM_NAMESPACE" "$etcd_pod" -- etcdctl \
        --endpoints=https://127.0.0.1:2379 \
        --cacert=/var/lib/rancher/k3s/server/tls/etcd/server-ca.crt \
        --cert=/var/lib/rancher/k3s/server/tls/etcd/server-client.crt \
        --key=/var/lib/rancher/k3s/server/tls/etcd/server-client.key \
        endpoint health; then
        log "SUCCESS" "etcd cluster is healthy"
        return 0
    else
        log "ERROR" "etcd cluster health check failed"
        return 1
    fi
}

# Function to get etcd cluster status
get_etcd_status() {
    local etcd_pod
    etcd_pod=$(get_etcd_pod)
    
    log "INFO" "Getting etcd cluster status..."
    
    kubectl exec -n "$KUBE_SYSTEM_NAMESPACE" "$etcd_pod" -- etcdctl \
        --endpoints=https://127.0.0.1:2379 \
        --cacert=/var/lib/rancher/k3s/server/tls/etcd/server-ca.crt \
        --cert=/var/lib/rancher/k3s/server/tls/etcd/server-client.crt \
        --key=/var/lib/rancher/k3s/server/tls/etcd/server-client.key \
        endpoint status --write-out=table
}

# Function to create test data
create_test_data() {
    log "INFO" "Creating test data in namespace $TEST_NAMESPACE..."
    
    # Create test namespace
    kubectl create namespace "$TEST_NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -
    
    # Create test ConfigMap
    kubectl create configmap test-config \
        --from-literal=test-key="test-value-$(date +%s)" \
        --from-literal=backup-time="$(date)" \
        --from-literal=cluster-info="$(kubectl cluster-info | head -1)" \
        -n "$TEST_NAMESPACE" \
        --dry-run=client -o yaml | kubectl apply -f -
    
    # Create test Secret
    kubectl create secret generic test-secret \
        --from-literal=secret-key="secret-value-$(date +%s)" \
        --from-literal=backup-id="$(uuidgen || echo 'test-backup-id')" \
        -n "$TEST_NAMESPACE" \
        --dry-run=client -o yaml | kubectl apply -f -
    
    # Create test Deployment
    cat <<EOF | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: test-app
  namespace: $TEST_NAMESPACE
  labels:
    app: chaos-test
spec:
  replicas: 1
  selector:
    matchLabels:
      app: chaos-test
  template:
    metadata:
      labels:
        app: chaos-test
    spec:
      containers:
      - name: test-container
        image: nginx:alpine
        ports:
        - containerPort: 80
        env:
        - name: BACKUP_VALIDATION
          value: "true"
        - name: TEST_TIME
          value: "$(date)"
EOF
    
    # Wait for deployment to be ready
    kubectl wait --for=condition=available deployment/test-app -n "$TEST_NAMESPACE" --timeout=60s
    
    log "SUCCESS" "Test data created successfully"
}

# Function to verify test data
verify_test_data() {
    log "INFO" "Verifying test data exists..."
    
    # Check namespace
    if ! kubectl get namespace "$TEST_NAMESPACE" >/dev/null 2>&1; then
        log "ERROR" "Test namespace $TEST_NAMESPACE not found"
        return 1
    fi
    
    # Check ConfigMap
    if ! kubectl get configmap test-config -n "$TEST_NAMESPACE" >/dev/null 2>&1; then
        log "ERROR" "Test ConfigMap not found"
        return 1
    fi
    
    # Check Secret
    if ! kubectl get secret test-secret -n "$TEST_NAMESPACE" >/dev/null 2>&1; then
        log "ERROR" "Test Secret not found"
        return 1
    fi
    
    # Check Deployment
    if ! kubectl get deployment test-app -n "$TEST_NAMESPACE" >/dev/null 2>&1; then
        log "ERROR" "Test Deployment not found"
        return 1
    fi
    
    # Verify deployment is ready
    if kubectl get deployment test-app -n "$TEST_NAMESPACE" -o jsonpath='{.status.readyReplicas}' | grep -q "1"; then
        log "SUCCESS" "All test data verified successfully"
        return 0
    else
        log "ERROR" "Test deployment is not ready"
        return 1
    fi
}

# Function to create etcd backup
create_backup() {
    local backup_file="${1:-${BACKUP_FILE_PREFIX}-$(date +%Y%m%d-%H%M%S).db}"
    local etcd_pod
    etcd_pod=$(get_etcd_pod)
    
    log "INFO" "Creating etcd backup: $backup_file"
    
    # Create backup
    if kubectl exec -n "$KUBE_SYSTEM_NAMESPACE" "$etcd_pod" -- etcdctl \
        --endpoints=https://127.0.0.1:2379 \
        --cacert=/var/lib/rancher/k3s/server/tls/etcd/server-ca.crt \
        --cert=/var/lib/rancher/k3s/server/tls/etcd/server-client.crt \
        --key=/var/lib/rancher/k3s/server/tls/etcd/server-client.key \
        snapshot save "$SNAPSHOT_DIR/$backup_file"; then
        
        log "SUCCESS" "Backup created: $backup_file"
        
        # Verify backup file exists and get size
        local backup_size
        backup_size=$(kubectl exec -n "$KUBE_SYSTEM_NAMESPACE" "$etcd_pod" -- ls -lh "$SNAPSHOT_DIR/$backup_file" | awk '{print $5}')
        log "INFO" "Backup file size: $backup_size"
        
        # Verify backup integrity
        if kubectl exec -n "$KUBE_SYSTEM_NAMESPACE" "$etcd_pod" -- etcdctl \
            --write-out=table snapshot status "$SNAPSHOT_DIR/$backup_file"; then
            log "SUCCESS" "Backup integrity verified"
            echo "$backup_file"
            return 0
        else
            log "ERROR" "Backup integrity check failed"
            return 1
        fi
    else
        log "ERROR" "Failed to create backup"
        return 1
    fi
}

# Function to list available backups
list_backups() {
    local etcd_pod
    etcd_pod=$(get_etcd_pod)
    
    log "INFO" "Listing available backup files..."
    
    kubectl exec -n "$KUBE_SYSTEM_NAMESPACE" "$etcd_pod" -- ls -la "$SNAPSHOT_DIR/" | grep -E "\\.db$" || {
        log "WARN" "No backup files found in $SNAPSHOT_DIR"
        return 1
    }
}

# Function to simulate data loss
simulate_data_loss() {
    log "INFO" "Simulating data loss by deleting test namespace..."
    
    if kubectl delete namespace "$TEST_NAMESPACE" --wait=true --timeout=60s; then
        log "SUCCESS" "Test namespace deleted (data loss simulated)"
        
        # Wait a bit and verify it's gone
        sleep 5
        if kubectl get namespace "$TEST_NAMESPACE" >/dev/null 2>&1; then
            log "ERROR" "Test namespace still exists after deletion"
            return 1
        else
            log "SUCCESS" "Data loss simulation completed"
            return 0
        fi
    else
        log "ERROR" "Failed to delete test namespace"
        return 1
    fi
}

# Function to simulate restore (recreate test data)
simulate_restore() {
    log "INFO" "Simulating restore process..."
    log "WARN" "In a real disaster recovery scenario, this would involve:"
    log "WARN" "1. Stopping all K3s services on all master nodes"
    log "WARN" "2. Running: k3s server --cluster-reset --cluster-reset-restore-path=$SNAPSHOT_DIR/<backup-file>"
    log "WARN" "3. Restarting remaining master nodes to rejoin the cluster"
    log "WARN" ""
    log "INFO" "For this validation, we'll recreate the test data to simulate successful restore"
    
    # Recreate test data
    create_test_data
    
    log "SUCCESS" "Restore simulation completed"
}

# Function to validate restore
validate_restore() {
    log "INFO" "Validating restore by checking test data..."
    
    # Verify test data exists
    if verify_test_data; then
        log "SUCCESS" "Restore validation successful - all test data present"
        
        # Additional checks
        local config_value
        config_value=$(kubectl get configmap test-config -n "$TEST_NAMESPACE" -o jsonpath='{.data.test-key}' 2>/dev/null || echo "")
        
        if [ -n "$config_value" ]; then
            log "INFO" "ConfigMap test-key value: $config_value"
        fi
        
        local secret_value
        secret_value=$(kubectl get secret test-secret -n "$TEST_NAMESPACE" -o jsonpath='{.data.secret-key}' 2>/dev/null | base64 -d 2>/dev/null || echo "")
        
        if [ -n "$secret_value" ]; then
            log "INFO" "Secret test-key value: $secret_value"
        fi
        
        # Check deployment status
        local ready_replicas
        ready_replicas=$(kubectl get deployment test-app -n "$TEST_NAMESPACE" -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
        log "INFO" "Test deployment ready replicas: $ready_replicas"
        
        return 0
    else
        log "ERROR" "Restore validation failed - test data missing"
        return 1
    fi
}

# Function to cleanup test resources
cleanup_test_resources() {
    log "INFO" "Cleaning up test resources..."
    
    # Delete test namespace
    if kubectl get namespace "$TEST_NAMESPACE" >/dev/null 2>&1; then
        kubectl delete namespace "$TEST_NAMESPACE" --wait=true --timeout=60s || {
            log "WARN" "Failed to delete test namespace cleanly"
        }
    fi
    
    # Clean up backup files (keep only the most recent 5)
    local etcd_pod
    etcd_pod=$(get_etcd_pod)
    
    log "INFO" "Cleaning up old backup files (keeping most recent 5)..."
    kubectl exec -n "$KUBE_SYSTEM_NAMESPACE" "$etcd_pod" -- sh -c "
        cd $SNAPSHOT_DIR && 
        ls -t ${BACKUP_FILE_PREFIX}-*.db 2>/dev/null | tail -n +6 | xargs -r rm -f
    " || log "WARN" "Failed to clean up old backup files"
    
    log "SUCCESS" "Cleanup completed"
}

# Function to run full validation
run_full_validation() {
    local cleanup_after="${1:-false}"
    
    log "INFO" "Starting full etcd backup and restore validation..."
    
    # Step 1: Check etcd health
    if ! check_etcd_health; then
        log "ERROR" "etcd health check failed - aborting validation"
        return 1
    fi
    
    # Step 2: Create test data
    if ! create_test_data; then
        log "ERROR" "Failed to create test data - aborting validation"
        return 1
    fi
    
    # Step 3: Create backup
    local backup_file
    if backup_file=$(create_backup); then
        log "SUCCESS" "Backup phase completed: $backup_file"
    else
        log "ERROR" "Backup creation failed - aborting validation"
        cleanup_test_resources
        return 1
    fi
    
    # Step 4: Simulate data loss
    if ! simulate_data_loss; then
        log "ERROR" "Data loss simulation failed - aborting validation"
        return 1
    fi
    
    # Step 5: Simulate restore
    if ! simulate_restore; then
        log "ERROR" "Restore simulation failed - validation incomplete"
        return 1
    fi
    
    # Step 6: Validate restore
    if ! validate_restore; then
        log "ERROR" "Restore validation failed"
        [ "$cleanup_after" = "true" ] && cleanup_test_resources
        return 1
    fi
    
    # Step 7: Final etcd health check
    if ! check_etcd_health; then
        log "ERROR" "Post-restore etcd health check failed"
        [ "$cleanup_after" = "true" ] && cleanup_test_resources
        return 1
    fi
    
    log "SUCCESS" "ðŸŽ‰ Full etcd backup and restore validation completed successfully!"
    
    # Cleanup if requested
    if [ "$cleanup_after" = "true" ]; then
        cleanup_test_resources
    fi
    
    return 0
}

# Parse command line arguments
CLEANUP_AFTER=false
VERBOSE=false
ACTION="validate"
BACKUP_FILE=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            usage
            exit 0
            ;;
        -n|--namespace)
            TEST_NAMESPACE="$2"
            shift 2
            ;;
        -f|--backup-file)
            BACKUP_FILE="$2"
            shift 2
            ;;
        -c|--cleanup)
            CLEANUP_AFTER=true
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            set -x
            shift
            ;;
        -*)
            log "ERROR" "Unknown option: $1"
            usage
            exit 1
            ;;
        *)
            ACTION="$1"
            shift
            ;;
    esac
done

# Main execution
main() {
    log "INFO" "etcd Backup Validation Script"
    log "INFO" "Action: $ACTION"
    log "INFO" "Test namespace: $TEST_NAMESPACE"
    log "INFO" "Cleanup after: $CLEANUP_AFTER"
    
    case "$ACTION" in
        "validate")
            run_full_validation "$CLEANUP_AFTER"
            ;;
        "backup-only")
            check_etcd_health && create_test_data && create_backup "$BACKUP_FILE"
            ;;
        "restore-only")
            check_etcd_health && simulate_restore && validate_restore
            ;;
        "list-backups")
            list_backups
            ;;
        "cleanup")
            cleanup_test_resources
            ;;
        *)
            log "ERROR" "Unknown action: $ACTION"
            usage
            exit 1
            ;;
    esac
}

# Run main function
main 