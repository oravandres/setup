#!/bin/bash
# Sealed Secrets Management Script
# Generated by Ansible

set -euo pipefail

# Configuration
SEALED_SECRETS_NAMESPACE="{{ sealed_secrets_namespace }}"
KUBECONFIG="{{ kubeconfig_path | default('/etc/rancher/k3s/k3s.yaml') }}"
PUBLIC_KEY_PATH="/tmp/sealed-secrets-public.pem"
GITOPS_SECRETS_DIR="{{ gitops_secrets_directory }}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check prerequisites
check_prerequisites() {
    log_info "Checking prerequisites..."
    
    if ! command -v kubeseal &> /dev/null; then
        log_error "kubeseal command not found. Please install it first."
        exit 1
    fi
    
    if ! command -v kubectl &> /dev/null; then
        log_error "kubectl command not found. Please install it first."
        exit 1
    fi
    
    if [[ ! -f "$KUBECONFIG" ]]; then
        log_error "Kubeconfig file not found at $KUBECONFIG"
        exit 1
    fi
    
    if [[ ! -f "$PUBLIC_KEY_PATH" ]]; then
        log_warning "Public key not found at $PUBLIC_KEY_PATH, fetching..."
        fetch_public_key
    fi
    
    log_success "Prerequisites check passed"
}

# Fetch public key from cluster
fetch_public_key() {
    log_info "Fetching Sealed Secrets public key..."
    
    export KUBECONFIG="$KUBECONFIG"
    kubectl get secret -n "$SEALED_SECRETS_NAMESPACE" \
        -l sealedsecrets.bitnami.com/sealed-secrets-key=active \
        -o jsonpath='{.items[0].data.tls\.crt}' | base64 -d > "$PUBLIC_KEY_PATH"
    
    if [[ -f "$PUBLIC_KEY_PATH" ]]; then
        log_success "Public key saved to $PUBLIC_KEY_PATH"
    else
        log_error "Failed to fetch public key"
        exit 1
    fi
}

# Create sealed secret from input
create_sealed_secret() {
    local secret_name="$1"
    local namespace="$2"
    local environment="$3"
    local secret_type="${4:-generic}"
    
    log_info "Creating sealed secret: $secret_name in namespace: $namespace"
    
    # Create temporary file for the regular secret
    local temp_secret_file=$(mktemp)
    local output_file="$GITOPS_SECRETS_DIR/$environment/${secret_name}-sealed-secret.yaml"
    
    # Create the directory if it doesn't exist
    mkdir -p "$GITOPS_SECRETS_DIR/$environment"
    
    case "$secret_type" in
        "generic")
            create_generic_secret "$secret_name" "$namespace" "$temp_secret_file"
            ;;
        "tls")
            create_tls_secret "$secret_name" "$namespace" "$temp_secret_file"
            ;;
        "docker-registry")
            create_docker_registry_secret "$secret_name" "$namespace" "$temp_secret_file"
            ;;
        *)
            log_error "Unknown secret type: $secret_type"
            rm -f "$temp_secret_file"
            exit 1
            ;;
    esac
    
    # Seal the secret
    kubeseal --cert "$PUBLIC_KEY_PATH" --format=yaml < "$temp_secret_file" > "$output_file"
    
    # Clean up
    rm -f "$temp_secret_file"
    
    log_success "Sealed secret created: $output_file"
    log_info "You can now commit this file to your GitOps repository"
}

# Create generic secret
create_generic_secret() {
    local secret_name="$1"
    local namespace="$2"
    local temp_file="$3"
    
    log_info "Creating generic secret..."
    
    # Collect key-value pairs
    declare -A secret_data
    while true; do
        echo -n "Enter key name (or 'done' to finish): "
        read -r key
        
        if [[ "$key" == "done" ]]; then
            break
        fi
        
        echo -n "Enter value for '$key': "
        read -rs value
        echo
        
        secret_data["$key"]="$value"
    done
    
    # Create kubectl command
    local kubectl_cmd="kubectl create secret generic $secret_name --namespace=$namespace --dry-run=client -o yaml"
    
    for key in "${!secret_data[@]}"; do
        kubectl_cmd+=" --from-literal=$key=${secret_data[$key]}"
    done
    
    # Execute and save to temp file
    eval "$kubectl_cmd" > "$temp_file"
}

# Create TLS secret
create_tls_secret() {
    local secret_name="$1"
    local namespace="$2"
    local temp_file="$3"
    
    log_info "Creating TLS secret..."
    
    echo -n "Enter path to TLS certificate file: "
    read -r cert_file
    
    echo -n "Enter path to TLS private key file: "
    read -r key_file
    
    if [[ ! -f "$cert_file" ]] || [[ ! -f "$key_file" ]]; then
        log_error "Certificate or key file not found"
        exit 1
    fi
    
    kubectl create secret tls "$secret_name" \
        --namespace="$namespace" \
        --cert="$cert_file" \
        --key="$key_file" \
        --dry-run=client -o yaml > "$temp_file"
}

# Create Docker registry secret
create_docker_registry_secret() {
    local secret_name="$1"
    local namespace="$2"
    local temp_file="$3"
    
    log_info "Creating Docker registry secret..."
    
    echo -n "Enter Docker registry server: "
    read -r server
    
    echo -n "Enter Docker registry username: "
    read -r username
    
    echo -n "Enter Docker registry password: "
    read -rs password
    echo
    
    echo -n "Enter Docker registry email: "
    read -r email
    
    kubectl create secret docker-registry "$secret_name" \
        --namespace="$namespace" \
        --docker-server="$server" \
        --docker-username="$username" \
        --docker-password="$password" \
        --docker-email="$email" \
        --dry-run=client -o yaml > "$temp_file"
}

# Show usage
usage() {
    cat << EOF
Usage: $0 [COMMAND] [OPTIONS]

Commands:
    create          Create a new sealed secret
    fetch-key       Fetch the public key from the cluster
    check           Check prerequisites
    help            Show this help message

Examples:
    $0 create myapp-secrets default dev generic
    $0 create tls-cert default production tls
    $0 fetch-key
    $0 check

EOF
}

# Main execution
main() {
    case "${1:-help}" in
        "create")
            if [[ $# -ne 5 ]]; then
                log_error "Usage: $0 create <secret-name> <namespace> <environment> <type>"
                log_info "Types: generic, tls, docker-registry"
                exit 1
            fi
            check_prerequisites
            create_sealed_secret "$2" "$3" "$4" "$5"
            ;;
        "fetch-key")
            fetch_public_key
            ;;
        "check")
            check_prerequisites
            ;;
        "help"|*)
            usage
            ;;
    esac
}

main "$@" 